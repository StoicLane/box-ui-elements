{"version":3,"sources":["../../../src/components/table/makeSelectable.js"],"names":["PropTypes","React","Component","Set","ImmutablePropTypes","classNames","FormattedMessage","Hotkeys","HotkeyRecord","messages","shiftSelect","SEARCH_TIMER_DURATION","makeSelectable","BaseTable","originalDisplayName","displayName","name","props","focusedIndex","undefined","selectedItems","newFocusedIndex","onSelect","previousIndex","state","setState","isSet","toJS","hotkeyType","key","description","shiftXDescription","handler","selectToggle","type","selectAllDescription","event","data","preventDefault","deselectAllDescription","downDescription","Math","min","length","upDescription","max","shiftDownDescription","handleShiftKeyDown","shiftUpDescription","isTargetSlider","gridColumnCount","handleShiftKeyDownForGrid","enableHotkeys","isGridView","hotkeys","viewSpecificHotKeyConfigs","getGridViewHotKeyConfigs","getListViewHotKeyConfigs","getSharedHotkeyConfigs","loadedData","rowIndex","getProcessedProps","has","delete","add","anchorIndex","selectedRows","reduce","rows","item","i","push","newSelectedRows","newSelectedItems","map","size","index","metaKey","ctrlKey","shiftKey","selectRange","selectOne","blurTimerID","setTimeout","clearFocus","clearTimeout","boundary","focusedIndexData","newFocusedIndexData","union","selectedItemIndecies","sourceIndex","targetIndex","dataSize","isSourceSelected","isTargetSelected","selectedItemIndices","isContiguousSelection","newSelectedItemIndices","searchStrings","target","hasAttribute","nodeName","which","searchTimeout","searchString","findIndex","string","trim","toLowerCase","indexOf","nativeEvent","role","document","addEventListener","handleKeyboardSearch","prevProps","prevState","onFocus","removeEventListener","className","focusedItem","getHotkeyConfigs","handleCheckboxClick","handleRowClick","handleRowFocus","handleTableBlur","handleTableFocus","array","isRequired","number","bool","func","oneOfType","set"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport { Set } from 'immutable';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport classNames from 'classnames';\nimport { FormattedMessage } from 'react-intl';\n\nimport { Hotkeys, HotkeyRecord } from '../hotkeys';\nimport messages from './messages';\nimport shiftSelect from './shiftSelect';\n\nconst SEARCH_TIMER_DURATION = 1000;\n\nfunction makeSelectable(BaseTable) {\n    const originalDisplayName = BaseTable.displayName || BaseTable.name || 'Table';\n\n    return class SelectableTable extends Component {\n        static displayName = `Selectable(${originalDisplayName})`;\n\n        static propTypes = {\n            className: PropTypes.string,\n            /** Array of unique IDs of the items in the table. Each item should be a string or number, in the order they appear in the table. */\n            data: PropTypes.array.isRequired,\n            gridColumnCount: PropTypes.number,\n            isGridView: PropTypes.bool,\n            /** Called when focus changes. `(focusedIndex: number) => void` */\n            onFocus: PropTypes.func,\n            /** Called when selection changes. `(selectedItems: Array<string> | Array<number> | Set<string> | Set<number>) => void` */\n            onSelect: PropTypes.func.isRequired,\n            /**\n             * Array of strings for keyboard search corresponding to the data prop. If not provided, keyboard search won't work.\n             * Example: data = ['f_123', 'f_456'], and corresponding searchStrings = ['file.png', 'another file.pdf']\n             */\n            searchStrings: PropTypes.array,\n            /**\n             * Array of IDs that are currently selected, in any order.\n             * If you pass a native JS array, then your onSelect function will be called with a native JS array;\n             * likewise, if you pass an ImmutableJS Set, then your onSelect function will be called\n             * with an ImmutableJS Set.\n             */\n            selectedItems: PropTypes.oneOfType([PropTypes.array, ImmutablePropTypes.set]),\n            /** Array of unique IDs of the items in the table that are loaded and accessible. If not provided, this will default to all data */\n            loadedData: PropTypes.array,\n            enableHotkeys: PropTypes.bool,\n            /** Translated type for hotkeys. If not provided, then the hotkeys will not appear in the help modal. */\n            hotkeyType: PropTypes.string,\n        };\n\n        static defaultProps = {\n            selectedItems: new Set(),\n        };\n\n        constructor(props) {\n            super(props);\n\n            this.anchorIndex = 0;\n\n            this.searchString = '';\n            this.searchTimeout = null;\n\n            // we have to store the previously focused index because a focus event\n            // will be fired before the click event; thus, in the click handler,\n            // the focusedItem will already be the new item\n            this.previousIndex = 0;\n\n            this.blurTimerID = null;\n        }\n\n        state = {\n            focusedIndex: undefined,\n        };\n\n        componentDidMount() {\n            document.addEventListener('keypress', this.handleKeyboardSearch);\n        }\n\n        componentDidUpdate(prevProps, prevState) {\n            if (prevState.focusedIndex !== this.state.focusedIndex && this.props.onFocus) {\n                this.props.onFocus(this.state.focusedIndex);\n            }\n        }\n\n        componentWillUnmount() {\n            document.removeEventListener('keypress', this.handleKeyboardSearch);\n            clearTimeout(this.blurTimerID);\n        }\n\n        onSelect = (selectedItems, newFocusedIndex) => {\n            const { onSelect } = this.props;\n\n            this.previousIndex = this.state.focusedIndex || 0;\n\n            this.setState({\n                focusedIndex: newFocusedIndex,\n            });\n\n            if (onSelect) {\n                // If selectedItems were given as an Immutable Set, they should also be returned as one,\n                // and vice versa if they were given as a native JS array\n                onSelect(Set.isSet(this.props.selectedItems) ? selectedItems : selectedItems.toJS());\n            }\n        };\n\n        getSharedHotkeyConfigs = () => {\n            const { hotkeyType } = this.props;\n            return [\n                new HotkeyRecord({\n                    key: 'shift+x',\n                    description: <FormattedMessage {...messages.shiftXDescription} />,\n                    handler: () => {\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        this.selectToggle(focusedIndex);\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: ['meta+a', 'ctrl+a'],\n                    description: <FormattedMessage {...messages.selectAllDescription} />,\n                    handler: event => {\n                        const { data } = this.props;\n\n                        event.preventDefault();\n\n                        this.onSelect(new Set(data), this.state.focusedIndex);\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'esc',\n                    description: <FormattedMessage {...messages.deselectAllDescription} />,\n                    handler: () => {\n                        this.onSelect(new Set(), this.state.focusedIndex);\n                    },\n                    type: hotkeyType,\n                }),\n            ];\n        };\n\n        getListViewHotKeyConfigs = () => {\n            const { hotkeyType } = this.props;\n            return [\n                new HotkeyRecord({\n                    key: 'down',\n                    description: <FormattedMessage {...messages.downDescription} />,\n                    handler: event => {\n                        const { data } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        event.preventDefault();\n\n                        const newFocusedIndex =\n                            focusedIndex !== undefined ? Math.min(focusedIndex + 1, data.length - 1) : 0;\n                        this.setState({ focusedIndex: newFocusedIndex });\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'up',\n                    description: <FormattedMessage {...messages.upDescription} />,\n                    handler: event => {\n                        const { focusedIndex = 0 } = this.state;\n\n                        event.preventDefault();\n\n                        const newFocusedIndex = Math.max(focusedIndex - 1, 0);\n                        this.setState({ focusedIndex: newFocusedIndex });\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'shift+down',\n                    description: <FormattedMessage {...messages.shiftDownDescription} />,\n                    handler: () => {\n                        const { data } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        const newFocusedIndex = Math.min(focusedIndex + 1, data.length - 1);\n                        this.handleShiftKeyDown(newFocusedIndex, data.length - 1);\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'shift+up',\n                    description: <FormattedMessage {...messages.shiftUpDescription} />,\n                    handler: () => {\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        const newFocusedIndex = Math.max(focusedIndex - 1, 0);\n                        this.handleShiftKeyDown(newFocusedIndex, 0);\n                    },\n                    type: hotkeyType,\n                }),\n            ];\n        };\n\n        getGridViewHotKeyConfigs = () => {\n            const { hotkeyType } = this.props;\n            return [\n                new HotkeyRecord({\n                    key: 'right',\n                    description: <FormattedMessage {...messages.downDescription} />,\n                    handler: event => {\n                        if (this.isTargetSlider(event)) {\n                            return;\n                        }\n\n                        const { data } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        event.preventDefault();\n\n                        const newFocusedIndex =\n                            focusedIndex !== undefined ? Math.min(focusedIndex + 1, data.length - 1) : 0;\n                        this.setState({ focusedIndex: newFocusedIndex });\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'left',\n                    description: <FormattedMessage {...messages.upDescription} />,\n                    handler: event => {\n                        if (this.isTargetSlider(event)) {\n                            return;\n                        }\n\n                        const { focusedIndex = 0 } = this.state;\n\n                        event.preventDefault();\n\n                        const newFocusedIndex = Math.max(focusedIndex - 1, 0);\n                        this.setState({ focusedIndex: newFocusedIndex });\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'down',\n                    description: <FormattedMessage {...messages.downDescription} />,\n                    handler: event => {\n                        if (this.isTargetSlider(event)) {\n                            return;\n                        }\n\n                        const { data, gridColumnCount } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        event.preventDefault();\n\n                        const newFocusedIndex =\n                            focusedIndex !== undefined ? Math.min(focusedIndex + gridColumnCount, data.length - 1) : 0;\n                        this.setState({ focusedIndex: newFocusedIndex });\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'up',\n                    description: <FormattedMessage {...messages.upDescription} />,\n                    handler: event => {\n                        if (this.isTargetSlider(event)) {\n                            return;\n                        }\n\n                        const { gridColumnCount } = this.props;\n                        const { focusedIndex = 0 } = this.state;\n\n                        event.preventDefault();\n\n                        const newFocusedIndex = Math.max(focusedIndex - gridColumnCount, 0);\n                        this.setState({ focusedIndex: newFocusedIndex });\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'shift+right',\n                    description: <FormattedMessage {...messages.shiftDownDescription} />,\n                    handler: () => {\n                        const { data } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        const newFocusedIndex = Math.min(focusedIndex + 1, data.length - 1);\n                        this.handleShiftKeyDownForGrid(newFocusedIndex, data.length - 1);\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'shift+left',\n                    description: <FormattedMessage {...messages.shiftUpDescription} />,\n                    handler: () => {\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        const newFocusedIndex = Math.max(focusedIndex - 1, 0);\n                        this.handleShiftKeyDownForGrid(newFocusedIndex, 0);\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'shift+down',\n                    description: <FormattedMessage {...messages.shiftDownDescription} />,\n                    handler: () => {\n                        const { data, gridColumnCount } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        const newFocusedIndex = Math.min(focusedIndex + gridColumnCount, data.length - 1);\n                        this.handleShiftKeyDownForGrid(newFocusedIndex, data.length - 1);\n                    },\n                    type: hotkeyType,\n                }),\n                new HotkeyRecord({\n                    key: 'shift+up',\n                    description: <FormattedMessage {...messages.shiftUpDescription} />,\n                    handler: () => {\n                        const { gridColumnCount } = this.props;\n                        const { focusedIndex } = this.state;\n\n                        if (focusedIndex === undefined) {\n                            return;\n                        }\n\n                        const newFocusedIndex = Math.max(focusedIndex - gridColumnCount, 0);\n                        this.handleShiftKeyDownForGrid(newFocusedIndex, 0);\n                    },\n                    type: hotkeyType,\n                }),\n            ];\n        };\n\n        getHotkeyConfigs = () => {\n            const { enableHotkeys, isGridView, gridColumnCount } = this.props;\n\n            if (!enableHotkeys && !this.hotkeys) {\n                this.hotkeys = [];\n            }\n\n            if (!this.hotkeys) {\n                const viewSpecificHotKeyConfigs =\n                    isGridView && gridColumnCount !== undefined\n                        ? this.getGridViewHotKeyConfigs()\n                        : this.getListViewHotKeyConfigs();\n\n                this.hotkeys = [...this.getSharedHotkeyConfigs(), ...viewSpecificHotKeyConfigs];\n            }\n\n            return this.hotkeys;\n        };\n\n        getProcessedProps = () => {\n            const { data, loadedData, selectedItems } = this.props;\n            return {\n                ...this.props,\n                loadedData: loadedData ? Set(loadedData) : Set(data),\n                selectedItems: Set.isSet(selectedItems) ? selectedItems : new Set(selectedItems),\n            };\n        };\n\n        hotkeys = null;\n\n        selectToggle = rowIndex => {\n            const { data, selectedItems } = this.getProcessedProps();\n\n            if (selectedItems.has(data[rowIndex])) {\n                this.onSelect(selectedItems.delete(data[rowIndex]), rowIndex);\n            } else {\n                this.onSelect(selectedItems.add(data[rowIndex]), rowIndex);\n            }\n\n            this.anchorIndex = rowIndex;\n        };\n\n        selectRange = rowIndex => {\n            const { data, selectedItems } = this.getProcessedProps();\n\n            // Don't change selection if we're shift-clicking the same row\n            if (rowIndex === this.previousIndex) {\n                return;\n            }\n\n            // Converts set of items to set of indices to do some slicing magic\n            const selectedRows = new Set(\n                data.reduce((rows, item, i) => {\n                    if (selectedItems.has(item)) {\n                        rows.push(i);\n                    }\n                    return rows;\n                }, []),\n            );\n\n            const newSelectedRows = shiftSelect(selectedRows, this.previousIndex, rowIndex, this.anchorIndex);\n\n            // Converts set back to set of items\n            const newSelectedItems = newSelectedRows.map(i => data[i]);\n\n            this.onSelect(newSelectedItems, rowIndex);\n        };\n\n        selectOne = rowIndex => {\n            const { data, selectedItems } = this.getProcessedProps();\n\n            // Don't change selection if we're clicking on a row that we've already selected\n            // This allows us to use the native onDoubleClick handler because we're referencing the\n            // same DOM node on double-click.\n            if (selectedItems.has(data[rowIndex]) && selectedItems.size === 1) {\n                return;\n            }\n\n            this.onSelect(new Set([data[rowIndex]]), rowIndex);\n            this.anchorIndex = rowIndex;\n        };\n\n        clearFocus = () => {\n            this.setState({\n                focusedIndex: undefined,\n            });\n        };\n\n        handleRowClick = (event, index) => {\n            if (event.metaKey || event.ctrlKey) {\n                this.selectToggle(index);\n            } else if (event.shiftKey) {\n                this.selectRange(index);\n            } else {\n                this.selectOne(index);\n            }\n        };\n\n        handleRowFocus = (event, index) => {\n            const { selectedItems } = this.getProcessedProps();\n            this.onSelect(selectedItems, index);\n        };\n\n        handleTableBlur = () => {\n            const { focusedIndex } = this.state;\n            if (focusedIndex !== undefined) {\n                // table may get focus back right away in the same tick, in which case we shouldn't clear focus\n                this.blurTimerID = setTimeout(this.clearFocus);\n            }\n        };\n\n        handleTableFocus = () => {\n            clearTimeout(this.blurTimerID);\n        };\n\n        handleShiftKeyDown = (newFocusedIndex, boundary) => {\n            const { data, selectedItems } = this.getProcessedProps();\n            const { focusedIndex } = this.state;\n\n            const focusedIndexData = data[focusedIndex];\n            const newFocusedIndexData = data[newFocusedIndex];\n\n            // if we're at a boundary of the table and the row is selected, no-op\n            if (focusedIndex === boundary && selectedItems.has(focusedIndexData)) {\n                return;\n            }\n\n            // if both the target and source are not selected, select them both\n            if (!selectedItems.has(focusedIndexData) && !selectedItems.has(newFocusedIndexData)) {\n                this.onSelect(selectedItems.union([focusedIndexData, newFocusedIndexData]), newFocusedIndex);\n                return;\n            }\n\n            // if target is not selected, select it\n            if (!selectedItems.has(newFocusedIndexData)) {\n                this.onSelect(selectedItems.add(newFocusedIndexData), newFocusedIndex);\n                return;\n            }\n\n            // if both source and target are selected, deselect source\n            if (selectedItems.has(newFocusedIndexData) && selectedItems.has(focusedIndexData)) {\n                this.onSelect(selectedItems.delete(focusedIndexData), newFocusedIndex);\n                return;\n            }\n\n            // if target is selected and source is not, select source\n            this.onSelect(selectedItems.add(focusedIndexData), newFocusedIndex);\n        };\n\n        isContiguousSelection = (selectedItemIndecies, sourceIndex, targetIndex) => {\n            if (sourceIndex < targetIndex && selectedItemIndecies.has(sourceIndex - 1)) {\n                return true;\n            }\n            if (targetIndex < sourceIndex && selectedItemIndecies.has(sourceIndex + 1)) {\n                return true;\n            }\n            return false;\n        };\n\n        handleShiftKeyDownForGrid = newFocusedIndex => {\n            const { data, loadedData, selectedItems } = this.getProcessedProps();\n            const { focusedIndex } = this.state;\n\n            const dataSize = data.length;\n            const targetIndex = newFocusedIndex < 0 ? 0 : Math.min(newFocusedIndex, dataSize - 1);\n            const isSourceSelected = selectedItems.has(data[focusedIndex]);\n            const isTargetSelected = selectedItems.has(data[targetIndex]);\n\n            // if data is not loaded, we don't want it to be able to be selected\n            if (!loadedData.has(data[targetIndex])) {\n                return;\n            }\n\n            const selectedItemIndices = new Set(\n                data.reduce((rows, item, i) => {\n                    if (selectedItems.has(item)) {\n                        rows.push(i);\n                    }\n                    return rows;\n                }, []),\n            );\n\n            // reset the anchor on a new selection block\n            if (\n                !isSourceSelected &&\n                !isTargetSelected &&\n                // if we are starting a new mass selection adjacent selected block, we want to connect them\n                !this.isContiguousSelection(selectedItemIndices, focusedIndex, targetIndex)\n            ) {\n                this.anchorIndex = focusedIndex;\n            }\n\n            const newSelectedItemIndices = shiftSelect(\n                selectedItemIndices,\n                focusedIndex,\n                targetIndex,\n                this.anchorIndex,\n            );\n\n            const newSelectedItems = newSelectedItemIndices.map(i => data[i]);\n\n            this.onSelect(newSelectedItems, targetIndex);\n        };\n\n        handleKeyboardSearch = event => {\n            const { searchStrings } = this.props;\n\n            if (!searchStrings) {\n                return;\n            }\n\n            if (\n                event.target.hasAttribute('contenteditable') ||\n                event.target.nodeName === 'INPUT' ||\n                event.target.nodeName === 'TEXTAREA'\n            ) {\n                return;\n            }\n\n            // character keys have a value for event.which\n            if (event.which === 0) {\n                return;\n            }\n\n            if (this.searchTimeout) {\n                clearTimeout(this.searchTimeout);\n            }\n\n            this.searchString += event.key;\n            this.searchTimeout = setTimeout(() => {\n                this.searchString = '';\n            }, SEARCH_TIMER_DURATION);\n\n            const index = searchStrings.findIndex(\n                string =>\n                    string\n                        .trim()\n                        .toLowerCase()\n                        .indexOf(this.searchString) === 0,\n            );\n\n            if (index !== -1) {\n                this.setState({ focusedIndex: index });\n            }\n        };\n\n        handleCheckboxClick = (event, index) => {\n            if (event.nativeEvent.shiftKey) {\n                this.selectRange(index);\n            } else {\n                this.selectToggle(index);\n            }\n        };\n\n        isTargetSlider = event => event.target?.role === 'slider';\n\n        render() {\n            const { className, data } = this.props;\n            const { focusedIndex } = this.state;\n            const focusedItem = data[focusedIndex];\n\n            return (\n                <Hotkeys configs={this.getHotkeyConfigs()}>\n                    <BaseTable\n                        {...this.props}\n                        className={classNames(className, 'is-selectable')}\n                        focusedIndex={focusedIndex}\n                        focusedItem={focusedItem}\n                        onCheckboxClick={this.handleCheckboxClick}\n                        onRowClick={this.handleRowClick}\n                        onRowFocus={this.handleRowFocus}\n                        onTableBlur={this.handleTableBlur}\n                        onTableFocus={this.handleTableFocus}\n                    />\n                </Hotkeys>\n            );\n        }\n    };\n}\n\nexport default makeSelectable;\n"],"file":"makeSelectable.js"}
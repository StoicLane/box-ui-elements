{"version":3,"sources":["../../../src/features/security-cloud-game/utils.js"],"names":["getRandomCloudPosition","cloudSize","height","width","x","Math","random","y","checkOverlap","dragCloudPosition","dropCloudPosition","dragLeft","dragTop","dragRight","dragBottom","dropLeft","dropTop","dropMidX","dropMidY","getGridPosition","position","gridTrackSize","row","floor","column"],"mappings":"AAAA;;;;AAIA,IAAMA,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,SAAD,EAAYC,MAAZ,EAAoBC,KAApB,EAA8B;AACzD;AACA,MAAMC,CAAC,GAAGC,IAAI,CAACC,MAAL,MAAiBH,KAAK,GAAGF,SAAR,GAAoBE,KAAK,GAAG,IAA7C,CAAV,CAFyD,CAGzD;;AACA,MAAMI,CAAC,GAAGF,IAAI,CAACC,MAAL,MAAiBJ,MAAM,GAAGD,SAAT,GAAqBC,MAAM,GAAG,IAA/C,CAAV;AAEA,SAAO;AAAEE,IAAAA,CAAC,EAADA,CAAF;AAAKG,IAAAA,CAAC,EAADA;AAAL,GAAP;AACH,CAPD;AASA;;;;;;;;;;AAQA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,iBAAD,EAAoBC,iBAApB,EAAuCT,SAAvC,EAAqD;AAAA,MAC3DU,QAD2D,GAClCF,iBADkC,CAC9DL,CAD8D;AAAA,MAC9CQ,OAD8C,GAClCH,iBADkC,CACjDF,CADiD;AAEtE,MAAMM,SAAS,GAAGF,QAAQ,GAAGV,SAA7B;AACA,MAAMa,UAAU,GAAGF,OAAO,GAAGX,SAA7B;AAHsE,MAK3Dc,QAL2D,GAKlCL,iBALkC,CAK9DN,CAL8D;AAAA,MAK9CY,OAL8C,GAKlCN,iBALkC,CAKjDH,CALiD;AAMtE,MAAMU,QAAQ,GAAGF,QAAQ,GAAGd,SAAS,GAAG,CAAxC;AACA,MAAMiB,QAAQ,GAAGF,OAAO,GAAGf,SAAS,GAAG,CAAvC;AAEA,SAAO,EAAEa,UAAU,GAAGI,QAAb,IAAyBN,OAAO,GAAGM,QAAnC,IAA+CP,QAAQ,GAAGM,QAA1D,IAAsEJ,SAAS,GAAGI,QAApF,CAAP;AACH,CAVD;AAYA;;;;;;;;AAMA,IAAME,eAAe,GAAG,SAAlBA,eAAkB,CAACC,QAAD,EAAWC,aAAX;AAAA,SAA8B;AAClDC,IAAAA,GAAG,EAAEjB,IAAI,CAACkB,KAAL,CAAWH,QAAQ,CAACb,CAAT,GAAac,aAAxB,CAD6C;AAElDG,IAAAA,MAAM,EAAEnB,IAAI,CAACkB,KAAL,CAAWH,QAAQ,CAAChB,CAAT,GAAaiB,aAAxB;AAF0C,GAA9B;AAAA,CAAxB;;AAKA,SAASb,YAAT,EAAuBW,eAAvB,EAAwCnB,sBAAxC","sourcesContent":["/**\n * Gets a random {x,y} position to place a cloud within the game board dimensions.\n * @returns {Object} - the {x,y} coordinates for the cloud\n */\nconst getRandomCloudPosition = (cloudSize, height, width) => {\n    // get random x position.  calculate using width of board - cloudSize - some extra padding (1% of width);\n    const x = Math.random() * (width - cloudSize - width * 0.01);\n    // get random y position.  calculate using height of board - cloudSize - some extra padding (1% of height);\n    const y = Math.random() * (height - cloudSize - height * 0.01);\n\n    return { x, y };\n};\n\n/**\n * Checks if a given position has already been occupied.\n * The actual calculations checks if the midpoint of the dropcloud image is contained within the drag cloud image.\n * @param {object} dragCloudPosition - the x,y coordinates of drag cloud\n * @param {object} dropCloudPosition - the x,y coordinates of drop cloud\n * @param {number} cloudSize - size of the cloud objects\n * @returns {boolean} - true if there is an overlap, false otherwise\n */\nconst checkOverlap = (dragCloudPosition, dropCloudPosition, cloudSize) => {\n    const { x: dragLeft, y: dragTop } = dragCloudPosition;\n    const dragRight = dragLeft + cloudSize;\n    const dragBottom = dragTop + cloudSize;\n\n    const { x: dropLeft, y: dropTop } = dropCloudPosition;\n    const dropMidX = dropLeft + cloudSize / 2;\n    const dropMidY = dropTop + cloudSize / 2;\n\n    return !(dragBottom < dropMidY || dragTop > dropMidY || dragLeft > dropMidX || dragRight < dropMidX);\n};\n\n/**\n * Get row and column numbers in grid.\n * @param {object} position - the x,y coordinates\n * @param {number} gridTrackSize - size of the space between two adjacent grid lines\n * @returns {object}\n */\nconst getGridPosition = (position, gridTrackSize) => ({\n    row: Math.floor(position.y / gridTrackSize),\n    column: Math.floor(position.x / gridTrackSize),\n});\n\nexport { checkOverlap, getGridPosition, getRandomCloudPosition };\n"],"file":"utils.js"}
function _templateObject19() {
  var data = _taggedTemplateLiteral(["\n                hasTasks\n                ", "\n                ", "\n            "]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral(["\n                hasTasks\n                ", "\n                ", "\n            "]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["\n                expectedOptions                         | hasTasks\n                ", "          | ", "\n                ", " | ", "\n            "]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["\n                hasTasks\n                ", "\n                ", "\n            "]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["\n            status        | expected\n            ", "  | ", "\n            ", "     | ", "\n            ", " | ", "\n            ", "     | ", "\n        "]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["\n            status        | expected\n            ", "  | ", "\n            ", "     | ", "\n            ", " | ", "\n            ", "     | ", "\n        "]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral(["\n            commentId    | expected\n            ", " | ", "\n            ", "     | ", "\n            ", "     | ", "\n        "]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["\n            type              | expected\n            ", "   | ", "\n            ", " | ", "\n            ", "      | ", "\n            ", " | ", "\n            ", "         | ", "\n        "]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral(["\n            type              | expected\n            ", "   | ", "\n            ", " | ", "\n            ", "      | ", "\n            ", " | ", "\n            ", "         | ", "\n        "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["\n            getFocusableFeedItemByIdResult | getCommentFeedItemByReplyIdResult | expected\n            ", "                       | ", "                          | ", "\n            ", "                        | ", "                          | ", "\n            ", "                       | ", "                           | ", "\n        "]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n            feedItems                                                     | itemId       | expected\n            ", "                                                         | ", "     | ", "\n            ", "                                                         | ", " | ", "\n            ", " | ", "     | ", "\n            ", " | ", "     | ", "\n            ", " | ", "     | ", "\n            ", "                           | ", "     | ", "\n            ", "    | ", "     | ", "\n        "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n            feedItems                                | itemId       | expected\n            ", "                                    | ", " | ", "\n            ", "                                    | ", "     | ", "\n            ", "      | ", "     | ", "\n            ", "   | ", "     | ", "\n            ", "         | ", "     | ", "\n            ", " | ", "     | ", "\n            ", "      | ", "     | ", "\n        "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n            id           | type\n            ", " | ", "\n            ", "     | ", "\n            ", " | ", "\n        "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n            annotationsEnabled | appActivityEnabled | repliesEnabled | tasksEnabled | versionsEnabled | uaaIntegrationEnabled | expectedAnnotations | expectedAppActivity | expectedReplies | expectedTasks | expectedVersions | expectedUseUAA\n            ", "           | ", "           | ", "       | ", "     | ", "        | ", "              | ", "            | ", "            | ", "        | ", "      | ", "         | ", "\n            ", "            | ", "            | ", "        | ", "      | ", "         | ", "               | ", "             | ", "             | ", "         | ", "       | ", "          | ", "\n        "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n            id           | type         | isActiveEntryInFeedResult\n            ", " | ", " | ", "\n            ", "     | ", " | ", "\n            ", " | ", " | ", "\n            ", "     | ", "    | ", "\n        "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n                status       | text         | expectedStatus | expectedText\n                ", " | ", " | ", "   | ", "\n                ", "    | ", "     | ", "      | ", "\n            "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n            hasReplies\n            ", "\n            ", "\n        "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n            hasReplies\n            ", "\n            ", "\n        "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n            hasReplies\n            ", "\n            ", "\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import { shallow, mount } from 'enzyme';
import cloneDeep from 'lodash/cloneDeep';
import { ActivitySidebarComponent, activityFeedInlineError } from '../ActivitySidebar';
import ActivitySidebarFilter from '../ActivitySidebarFilter';
import { filterableActivityFeedItems, formattedReplies } from '../fixtures';
import { FEED_ITEM_TYPE_COMMENT } from '../../../constants';
jest.mock('lodash/debounce', function () {
  return jest.fn(function (i) {
    return i;
  });
});
jest.mock('lodash/uniqueId', function () {
  return function () {
    return 'uniqueId';
  };
}); // const mockReplace = jest.fn();
// jest.mock('lodash/uniqueId', () => () => 'uniqueId');

var userError = 'Bad box user!';
describe('elements/content-sidebar/ActivitySidebar', function () {
  var feedAPI = {
    createComment: jest.fn(),
    createReply: jest.fn(),
    createTaskNew: jest.fn(),
    createThreadedComment: jest.fn(),
    deleteAnnotation: jest.fn(),
    deleteComment: jest.fn(),
    deleteReply: jest.fn(),
    deleteTaskNew: jest.fn(),
    deleteThreadedComment: jest.fn(),
    feedItems: jest.fn(),
    fetchReplies: jest.fn(),
    fetchThreadedComment: jest.fn(),
    updateAnnotation: jest.fn(),
    updateComment: jest.fn(),
    updateFeedItem: jest.fn(),
    updateReply: jest.fn(),
    updateTaskCollaborator: jest.fn(),
    updateTaskNew: jest.fn(),
    updateThreadedComment: jest.fn()
  };
  var usersAPI = {
    get: jest.fn(),
    getAvatarUrlWithAccessToken: jest.fn().mockResolvedValue('foo'),
    getUser: jest.fn()
  };
  var fileCollaboratorsAPI = {
    getCollaboratorsWithQuery: jest.fn()
  };
  var api = {
    getUsersAPI: function getUsersAPI() {
      return usersAPI;
    },
    getFeedAPI: function getFeedAPI() {
      return feedAPI;
    },
    getFileCollaboratorsAPI: function getFileCollaboratorsAPI() {
      return fileCollaboratorsAPI;
    }
  };
  var file = {
    id: 'I_AM_A_FILE',
    file_version: {
      id: '123'
    }
  };
  var currentUser = {
    id: '123',
    name: 'foo bar'
  };
  var collaborators = {
    entries: [{
      id: '1',
      name: 'foo',
      item: {}
    }]
  };
  var onError = jest.fn();

  var getWrapper = function getWrapper() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return shallow(React.createElement(ActivitySidebarComponent, _extends({
      api: api,
      currentUser: currentUser,
      file: file,
      logger: {
        onReadyMetric: jest.fn()
      },
      onError: onError
    }, props)));
  };

  describe('constructor()', function () {
    var onReadyMetric;
    beforeEach(function () {
      var wrapper = getWrapper();
      onReadyMetric = wrapper.instance().props.logger.onReadyMetric;
    });
    test('should emit when js loaded', function () {
      expect(onReadyMetric).toHaveBeenCalledWith({
        endMarkName: expect.any(String)
      });
    });
  });
  describe('componentDidMount()', function () {
    var wrapper;
    var instance;
    beforeEach(function () {
      jest.spyOn(ActivitySidebarComponent.prototype, 'fetchFeedItems');
      wrapper = getWrapper();
      instance = wrapper.instance();
    });
    afterEach(function () {
      jest.restoreAllMocks();
    });
    test('should fetch the file and refresh the cache and fetch the current user', function () {
      expect(instance.fetchFeedItems).toHaveBeenCalledWith(true);
    });
  });
  describe('render()', function () {
    test('should render the activity feed sidebar', function () {
      var wrapper = getWrapper();
      expect(wrapper).toMatchSnapshot();
    });
  });
  describe('createTask()', function () {
    test('should throw an error if there is not the current user in the state', function () {
      var wrapper = getWrapper({
        currentUser: undefined
      });
      var instance = wrapper.instance();
      expect(function () {
        return instance.createTask();
      }).toThrow('Bad box user!');
    });
    test('should create the task and fetch the feed items', function () {
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      var message = 'message';
      var assignees = ['1', '2'];
      var dueAt = 'test';
      var taskType = 'GENERAL';
      var completionRule = 'ALL_ASSIGNEES';
      instance.fetchFeedItems = jest.fn();
      instance.createTask(message, assignees, taskType, dueAt, completionRule);
      expect(feedAPI.createTaskNew).toHaveBeenCalledWith(file, currentUser, message, assignees, taskType, dueAt, completionRule, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toHaveBeenCalled();
    });
  });
  describe('deleteTask()', function () {
    test('should call the deleteTask prop if it exists', function () {
      var id = '1;';
      var onTaskDelete = jest.fn();
      var wrapper = getWrapper({
        onTaskDelete: onTaskDelete
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      instance.deleteTask({
        id: id
      });
      expect(feedAPI.deleteTaskNew).toHaveBeenCalled();
      expect(instance.fetchFeedItems).toHaveBeenCalled();
    });
  });
  describe('deleteComment()', function () {
    test.each(_templateObject(), undefined, false)('should call the deleteComment API if it exists when hasReplies prop equals to $hasReplies', function (_ref) {
      var hasReplies = _ref.hasReplies;
      var wrapper = getWrapper({
        hasReplies: hasReplies
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      var id = '1';
      var permissions = {
        can_edit: false,
        can_delete: true
      };
      instance.deleteComment({
        id: id,
        permissions: permissions
      });
      expect(feedAPI.deleteComment).toBeCalledWith(file, id, permissions, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
    test('should call the deleteThreadedComment API if it exists when hasReplies prop equals to true', function () {
      var wrapper = getWrapper({
        hasReplies: true
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      var id = '1';
      var permissions = {
        can_edit: false,
        can_delete: true
      };
      instance.deleteComment({
        id: id,
        permissions: permissions
      });
      expect(feedAPI.deleteThreadedComment).toBeCalledWith(file, id, permissions, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('deleteReply()', function () {
    test('should call the deleteReply API and call emitAnnotationReplyDeleteEvent', function () {
      var mockEmitAnnotationReplyDeleteEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationReplyDeleteEvent: mockEmitAnnotationReplyDeleteEvent
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      var id = '1';
      var parentId = '123';
      var permissions = {
        can_edit: false,
        can_delete: true
      };
      instance.deleteReply({
        id: id,
        parentId: parentId,
        permissions: permissions
      });
      expect(feedAPI.deleteReply).toBeCalledWith(file, id, parentId, permissions, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
      expect(mockEmitAnnotationReplyDeleteEvent).toBeCalledWith(id, parentId, true);
    });
  });
  describe('deleteReplySuccessCallback()', function () {
    test('should call the feedSuccessCallback and emitAnnotationReplyDeleteEvent', function () {
      var mockEmitAnnotationReplyDeleteEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationReplyDeleteEvent: mockEmitAnnotationReplyDeleteEvent
      });
      var instance = wrapper.instance();
      instance.feedSuccessCallback = jest.fn();
      var id = '1';
      var parentId = '123';
      instance.deleteReplySuccessCallback(id, parentId);
      expect(instance.feedSuccessCallback).toBeCalled();
      expect(mockEmitAnnotationReplyDeleteEvent).toBeCalledWith(id, parentId);
    });
  });
  describe('feedSuccessCallback()', function () {
    var instance;
    var wrapper;
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
    });
    test('should fetch the feed items', function () {
      instance.feedSuccessCallback();
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('feedErrorCallback()', function () {
    var instance;
    var wrapper;
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      instance.errorCallback = jest.fn();
    });
    test('should invoke the generic error callback and fetch the items', function () {
      instance.feedErrorCallback();
      expect(instance.errorCallback).toBeCalled();
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('updateTask()', function () {
    var instance;
    var wrapper;
    var taskObj = {
      text: 'foo',
      id: 'bar'
    };
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
    });
    test('should call the update task API and fetch the items', function () {
      instance.updateTask(taskObj);
      expect(feedAPI.updateTaskNew).toBeCalled();
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('updateTaskAssignment()', function () {
    var instance;
    var wrapper;
    var onTaskAssignmentUpdate;
    beforeEach(function () {
      onTaskAssignmentUpdate = jest.fn();
      wrapper = getWrapper({
        onTaskAssignmentUpdate: onTaskAssignmentUpdate,
        file: file
      });
      instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      instance.feedSuccessCallback = jest.fn();
      instance.feedErrorCallback = jest.fn();
    });
    test('should call the update task assignment API and fetch the items', function () {
      instance.updateTaskAssignment('1', '2', 'foo', 'bar');
      expect(feedAPI.updateTaskCollaborator).toHaveBeenCalledWith(file, '1', '2', 'foo', expect.any(Function), instance.feedErrorCallback);
      expect(instance.fetchFeedItems).toBeCalled();
      var successCallback = feedAPI.updateTaskCollaborator.mock.calls[0][4];
      successCallback();
      expect(onTaskAssignmentUpdate).toHaveBeenCalledWith('1', '2', 'foo', '123');
    });
  });
  describe('createComment()', function () {
    test('should throw an error if missing current user', function () {
      var wrapper = getWrapper({
        currentUser: null
      });
      var instance = wrapper.instance();
      var message = 'foo';
      expect(function () {
        return instance.createComment(message, true);
      }).toThrow('Bad box user!');
    });
    test.each(_templateObject2(), undefined, false)('should call the createComment API and fetch the items when hasReplies prop equals to $hasReplies', function (_ref2) {
      var hasReplies = _ref2.hasReplies;
      var wrapper = getWrapper({
        hasReplies: hasReplies
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      var message = 'foo';
      var hasMention = true;
      instance.createComment(message, hasMention);
      expect(feedAPI.createComment).toBeCalledWith(file, currentUser, message, hasMention, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
    test('should call the createThreadedComment API and fetch the items when hasReplies prop equals to true', function () {
      var wrapper = getWrapper({
        hasReplies: true
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      var message = 'foo';
      var hasMention = true;
      instance.createComment(message, hasMention);
      expect(feedAPI.createThreadedComment).toBeCalledWith(file, currentUser, message, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('createReply()', function () {
    test('should throw an error if missing current user', function () {
      var wrapper = getWrapper({
        currentUser: undefined
      });
      var instance = wrapper.instance();
      expect(function () {
        return instance.createReply('123', FEED_ITEM_TYPE_COMMENT, 'abc', true);
      }).toThrow(userError);
    });
    test('should call the createReply API, fetch the items and call emitAnnotationReplyCreateEvent', function () {
      var mockEmitAnnotationReplyCreateEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationReplyCreateEvent: mockEmitAnnotationReplyCreateEvent
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      var parentId = '123';
      var parentType = FEED_ITEM_TYPE_COMMENT;
      var message = 'abc';
      instance.setState({
        currentUser: currentUser
      });
      instance.createReply(parentId, parentType, message);
      expect(feedAPI.createReply).toBeCalledWith(file, currentUser, parentId, parentType, message, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
      expect(mockEmitAnnotationReplyCreateEvent).toBeCalledWith({
        tagged_message: message
      }, 'uniqueId', parentId, true);
    });
  });
  describe('createReplySuccessCallback()', function () {
    test('should call the feedSuccessCallback and emitAnnotationReplyCreateEvent', function () {
      var mockEmitAnnotationReplyCreateEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationReplyCreateEvent: mockEmitAnnotationReplyCreateEvent
      });
      var instance = wrapper.instance();
      instance.feedSuccessCallback = jest.fn();
      var reply = {
        id: '1',
        status: 'resolved'
      };
      var parentId = '123';
      var eventRequestId = 'comment_123';
      instance.createReplySuccessCallback(eventRequestId, parentId, reply);
      expect(instance.feedSuccessCallback).toBeCalled();
      expect(mockEmitAnnotationReplyCreateEvent).toBeCalledWith(reply, eventRequestId, parentId);
    });
  });
  describe('updateComment()', function () {
    test.each(_templateObject3(), undefined, false)('should call updateComment API when hasReplies prop equals to $hasReplies', function (_ref3) {
      var hasReplies = _ref3.hasReplies;
      var wrapper = getWrapper({
        hasReplies: hasReplies
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      wrapper.instance().updateComment('123', 'hello', undefined, false, {
        can_edit: true,
        can_delete: true
      });
      expect(api.getFeedAPI().updateComment).toBeCalledWith(file, '123', 'hello', false, {
        can_edit: true,
        can_delete: true
      }, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
    describe('should call updateThreadedComment API when hasReplies prop equals to true', function () {
      test.each(_templateObject4(), undefined, undefined, undefined, undefined, 'open', 'foo', 'open', 'foo')('given status=$status and text=$text', function (_ref4) {
        var status = _ref4.status,
            text = _ref4.text,
            expectedStatus = _ref4.expectedStatus,
            expectedText = _ref4.expectedText;
        var wrapper = getWrapper({
          hasReplies: true
        });
        var instance = wrapper.instance();
        instance.fetchFeedItems = jest.fn();
        wrapper.instance().updateComment('123', text, status, false, {
          can_edit: true,
          can_delete: true
        });
        expect(api.getFeedAPI().updateThreadedComment).toBeCalledWith(file, '123', expectedText, expectedStatus, {
          can_edit: true,
          can_delete: true
        }, expect.any(Function), expect.any(Function));
        expect(instance.fetchFeedItems).toBeCalled();
      });
    });
  });
  describe('updateReply()', function () {
    test('should call updateReply API and call emitAnnotationReplyUpdateEvent', function () {
      var mockEmitAnnotationReplyUpdateEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationReplyUpdateEvent: mockEmitAnnotationReplyUpdateEvent
      });
      var instance = wrapper.instance();
      var parentId = '123';
      var text = 'abc';
      var reply = {
        id: '1',
        permissions: {
          can_edit: true
        }
      };
      instance.fetchFeedItems = jest.fn();
      wrapper.instance().updateReply(reply.id, parentId, text, reply.permissions);
      expect(api.getFeedAPI().updateReply).toBeCalledWith(file, reply.id, parentId, text, reply.permissions, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
      expect(mockEmitAnnotationReplyUpdateEvent).toBeCalledWith({
        id: reply.id,
        tagged_message: text
      }, parentId, true);
    });
  });
  describe('updateReplies()', function () {
    test('should call updateFeedItem API', function () {
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      wrapper.setState({
        feedItems: []
      });
      var id = '123';
      var replies = cloneDeep(formattedReplies);
      instance.fetchFeedItems = jest.fn();
      instance.updateReplies(id, replies);
      expect(api.getFeedAPI().updateFeedItem).toBeCalledWith({
        replies: replies
      }, id);
      expect(instance.fetchFeedItems).toBeCalled();
    });
    test('should disable active item if replies are being hidden and activeFeedEntryId belongs to a reply that is in currently being updated parent', function () {
      var historyReplace = jest.fn();
      var activeReplyId = '123';
      var wrapper = getWrapper({
        activeFeedEntryId: activeReplyId,
        history: {
          replace: historyReplace
        }
      });
      var instance = wrapper.instance();
      instance.getActiveCommentPath = jest.fn();
      var itemId = '999';
      var lastReplyId = '456';
      var replies = [{
        id: lastReplyId
      }];
      wrapper.setState({
        feedItems: [{
          id: itemId,
          replies: [{
            id: activeReplyId
          }, {
            id: lastReplyId
          }],
          type: 'comment'
        }]
      });
      instance.updateReplies(itemId, replies);
      expect(instance.getActiveCommentPath).toBeCalledWith();
      expect(historyReplace).toBeCalled();
    });
  });
  describe('fetchRepliesForFeedItems()', function () {
    test('should not call getActiveFeedEntryData if activeFeedEntryId is not set', function () {
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      instance.getActiveFeedEntryData = jest.fn();
      instance.fetchRepliesForFeedItems([]);
      expect(instance.getActiveFeedEntryData).not.toBeCalled();
    });
    test('should call getActiveFeedEntryData with given feedItems if activeFeedEntryId is set', function () {
      var wrapper = getWrapper({
        activeFeedEntryId: '123'
      });
      var instance = wrapper.instance();
      instance.getActiveFeedEntryData = jest.fn().mockImplementation(function () {
        return Promise.resolve();
      });
      var feedItems = [{
        id: '123'
      }];
      instance.fetchRepliesForFeedItems(feedItems);
      expect(instance.getActiveFeedEntryData).toBeCalledWith(feedItems);
    });
    test.each(_templateObject5(), undefined, undefined, true, '123', 'comment', true, undefined, undefined, false, '123', 'task', false)('should not call getFeedItemsWithReplies if isActiveEntryInFeed results with $isActiveEntryInFeedResult and getActiveFeedEntryData resolves with id=$id and type=$type',
    /*#__PURE__*/
    function () {
      var _ref5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(_ref6) {
        var id, type, isActiveEntryInFeedResult, wrapper, instance, feedItems;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                id = _ref6.id, type = _ref6.type, isActiveEntryInFeedResult = _ref6.isActiveEntryInFeedResult;
                wrapper = getWrapper({
                  activeFeedEntryId: '123'
                });
                instance = wrapper.instance();
                instance.getFeedItemsWithReplies = jest.fn();
                instance.isActiveEntryInFeed = jest.fn().mockImplementation(function () {
                  return isActiveEntryInFeedResult;
                });
                instance.getActiveFeedEntryData = jest.fn().mockImplementation(function () {
                  return Promise.resolve({
                    id: id,
                    type: type
                  });
                });
                feedItems = [{
                  id: '123'
                }];
                _context.next = 9;
                return instance.fetchRepliesForFeedItems(feedItems);

              case 9:
                expect(instance.getFeedItemsWithReplies).not.toBeCalled();

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref5.apply(this, arguments);
      };
    }());
    test('should call getFeedItemsWithReplies if getActiveFeedEntryData resolves with id and type of feed item that is not the feed ',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2() {
      var wrapper, instance, feedItems;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              wrapper = getWrapper({
                activeFeedEntryId: '123'
              });
              instance = wrapper.instance();
              instance.isActiveEntryInFeed = jest.fn().mockImplementation(function () {
                return false;
              });
              instance.getActiveFeedEntryData = jest.fn().mockImplementation(function () {
                return Promise.resolve({
                  id: '123',
                  type: 'comment'
                });
              });
              instance.getFeedItemsWithReplies = jest.fn().mockImplementation(function () {
                return Promise.resolve();
              });
              feedItems = [{
                id: '123',
                replies: [{
                  id: '456'
                }]
              }];
              _context2.next = 8;
              return instance.fetchRepliesForFeedItems(feedItems);

            case 8:
              expect(instance.getFeedItemsWithReplies).toBeCalledWith(feedItems, '123', 'comment');

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
  });
  describe('updateReplySuccessCallback()', function () {
    test('should call the feedSuccessCallback and emitAnnotationReplyUpdateEvent', function () {
      var mockEmitAnnotationReplyUpdateEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationReplyUpdateEvent: mockEmitAnnotationReplyUpdateEvent
      });
      var instance = wrapper.instance();
      instance.feedSuccessCallback = jest.fn();
      var onSuccess = jest.fn();
      var reply = {
        id: '1',
        status: 'resolved'
      };
      var parentId = '123';
      instance.updateReplySuccessCallback(parentId, onSuccess, reply);
      expect(instance.feedSuccessCallback).toBeCalled();
      expect(mockEmitAnnotationReplyUpdateEvent).toBeCalledWith(reply, parentId);
      expect(onSuccess).toBeCalled();
    });
  });
  describe('fetchFeedItems()', function () {
    var instance;
    var wrapper;
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
    });
    test('should fetch the feed items', function () {
      instance.fetchFeedItems();
      expect(feedAPI.feedItems).toBeCalled();
    });
    test.each(_templateObject6(), false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true)('should fetch the feed items based on features: annotationsEnabled=$annotationsEnabled, appActivityEnabled=$appActivityEnabled, repliesEnabled=$repliesEnabled, tasksEnabled=$tasksEnabled, versionsEnabled=$versionsEnabled and uaaIntegrationEnabled=$uaaIntegrationEnabled', function (_ref8) {
      var annotationsEnabled = _ref8.annotationsEnabled,
          appActivityEnabled = _ref8.appActivityEnabled,
          repliesEnabled = _ref8.repliesEnabled,
          tasksEnabled = _ref8.tasksEnabled,
          versionsEnabled = _ref8.versionsEnabled,
          uaaIntegrationEnabled = _ref8.uaaIntegrationEnabled,
          expectedAnnotations = _ref8.expectedAnnotations,
          expectedAppActivity = _ref8.expectedAppActivity,
          expectedReplies = _ref8.expectedReplies,
          expectedTasks = _ref8.expectedTasks,
          expectedVersions = _ref8.expectedVersions,
          expectedUseUAA = _ref8.expectedUseUAA;
      wrapper = getWrapper({
        features: {
          activityFeed: {
            annotations: {
              enabled: annotationsEnabled
            },
            appActivity: {
              enabled: appActivityEnabled
            },
            uaaIntegration: {
              enabled: uaaIntegrationEnabled
            }
          }
        },
        hasReplies: repliesEnabled,
        hasTasks: tasksEnabled,
        hasVersions: versionsEnabled
      });
      instance = wrapper.instance();
      instance.errorCallback = jest.fn();
      instance.fetchFeedItemsErrorCallback = jest.fn();
      instance.fetchFeedItemsSuccessCallback = jest.fn();
      instance.fetchFeedItems();
      expect(feedAPI.feedItems).toHaveBeenCalledWith(file, false, instance.fetchFeedItemsSuccessCallback, instance.fetchFeedItemsErrorCallback, instance.errorCallback, {
        shouldShowAnnotations: expectedAnnotations,
        shouldShowAppActivity: expectedAppActivity,
        shouldShowReplies: expectedReplies,
        shouldShowTasks: expectedTasks,
        shouldShowVersions: expectedVersions,
        shouldUseUAA: expectedUseUAA
      });
    });
    test('should call feedItems with fetchRepliesForFeedItems as success callback instead of fetchFeedItemsSuccessCallback when shouldShowReplies and shouldRefreshCache are true and active comment is set, ', function () {
      var shouldShowReplies = true;
      var shouldRefreshCache = true;
      wrapper = getWrapper({
        activeFeedEntryId: '123',
        activeFeedEntryType: 'comment',
        hasReplies: shouldShowReplies
      });
      instance = wrapper.instance();
      instance.errorCallback = jest.fn();
      instance.fetchFeedItemsErrorCallback = jest.fn();
      instance.fetchRepliesForFeedItems = jest.fn();
      instance.fetchFeedItems(shouldRefreshCache);
      expect(feedAPI.feedItems).toHaveBeenCalledWith(file, true, instance.fetchRepliesForFeedItems, instance.fetchFeedItemsErrorCallback, instance.errorCallback, {
        shouldShowAnnotations: false,
        shouldShowAppActivity: false,
        shouldShowReplies: true,
        shouldShowTasks: true,
        shouldShowVersions: true,
        shouldUseUAA: false
      });
    });
  });
  describe('fetchFeedItemsSuccessCallback()', function () {
    var feedItems = ['foo'];
    var instance;
    var logger;
    var wrapper;
    beforeEach(function () {
      logger = {
        onDataReadyMetric: jest.fn(),
        onReadyMetric: jest.fn()
      };
      wrapper = getWrapper({
        logger: logger
      });
      instance = wrapper.instance();
      instance.setState = jest.fn();
    });
    test('should set the feedItems in the state', function () {
      instance.fetchFeedItemsSuccessCallback(feedItems);
      expect(instance.setState).toBeCalledWith({
        feedItems: feedItems,
        activityFeedError: undefined
      });
    });
    test('should not call onDataReadyMetric if feedItems is <= 1', function () {
      instance.fetchFeedItemsSuccessCallback(feedItems);
      expect(logger.onDataReadyMetric).not.toHaveBeenCalled();
    });
    test('should call onDataReadyMetric if feedItems is > 1', function () {
      instance.fetchFeedItemsSuccessCallback(['foo', 'bar']);
      expect(logger.onDataReadyMetric).toHaveBeenCalledWith({
        endMarkName: 'activity_sidebar_data_ready',
        startMarkName: 'activity_sidebar_data_loading'
      }, file.id);
    });
  });
  describe('fetchFeedItemsErrorCallback()', function () {
    var instance;
    var wrapper;
    var feedItems = 'foo';
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      instance.setState = jest.fn();
    });
    test('should set the feedItems in the state', function () {
      instance.fetchFeedItemsErrorCallback(feedItems);
      expect(instance.setState).toBeCalledWith({
        feedItems: feedItems,
        activityFeedError: activityFeedInlineError
      });
      expect(onError).not.toHaveBeenCalled();
    });
    test('should call onError if errors is not empty', function () {
      instance.fetchFeedItemsErrorCallback(feedItems, []);
      expect(onError).not.toHaveBeenCalled();
      instance.fetchFeedItemsErrorCallback(feedItems, [{
        code: '0'
      }, {
        code: '1'
      }]);
      expect(onError).toHaveBeenCalledWith(expect.any(Error), 'fetch_activity_error', {
        showNotification: true,
        errors: ['0', '1']
      });
    });
  });
  describe('getCommentFeedItemWithReplies()', function () {
    test('should return given feedItem with given replies', function () {
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      var item = {
        id: '123'
      };
      var replies = [{
        id: '456'
      }];
      var expectedItem = {
        id: '123',
        replies: [{
          id: '456'
        }]
      };
      expect(instance.getCommentFeedItemWithReplies(item, replies)).toMatchObject(expectedItem);
    });
  });
  describe('getFeedItemsWithReplies()', function () {
    test.each(_templateObject7(), undefined, 'comment', '123', undefined, undefined, undefined)('should resolve with given feedItems if id=$id and type=$type',
    /*#__PURE__*/
    function () {
      var _ref9 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(_ref10) {
        var id, type, wrapper, instance, feedItems, result;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                id = _ref10.id, type = _ref10.type;
                wrapper = getWrapper();
                instance = wrapper.instance();
                feedItems = [{
                  id: '123'
                }];
                _context3.next = 6;
                return instance.getFeedItemsWithReplies(feedItems, id, type);

              case 6:
                result = _context3.sent;
                expect(result).toMatchObject(feedItems);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref9.apply(this, arguments);
      };
    }());
    test('should call fetchReplies feed api and resolve with updated feedItems',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4() {
      var wrapper, instance, feedItems, id, type, replies, expectedItem, expectedItems, result;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              wrapper = getWrapper();
              instance = wrapper.instance();
              feedItems = [{
                id: '123',
                type: 'comment'
              }];
              id = '123';
              type = 'comment';
              replies = [{
                id: '456'
              }, {
                id: '789'
              }];
              expectedItem = {
                id: '123',
                type: 'comment',
                replies: replies
              };
              expectedItems = [expectedItem];
              instance.isItemTypeComment = jest.fn().mockImplementation(function () {
                return true;
              });
              instance.getCommentFeedItemWithReplies = jest.fn().mockImplementation(function () {
                return expectedItem;
              });
              api.getFeedAPI().fetchReplies = jest.fn().mockImplementationOnce(function (fileParam, idParam, typeParam, successCallback) {
                successCallback(replies);
              });
              _context4.next = 13;
              return instance.getFeedItemsWithReplies(feedItems, id, type);

            case 13:
              result = _context4.sent;
              expect(api.getFeedAPI().fetchReplies).toBeCalledWith(file, id, type, expect.any(Function), expect.any(Function));
              expect(result).toMatchObject(expectedItems);

            case 16:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    test('should reject with error if fetchReplies is called and fails',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee5() {
      var wrapper, instance, feedItems, id, type, error;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              wrapper = getWrapper();
              instance = wrapper.instance();
              feedItems = [{
                id: '123',
                type: 'comment'
              }];
              id = '123';
              type = 'comment';
              error = {
                status: '500'
              };
              api.getFeedAPI().fetchReplies = jest.fn().mockImplementationOnce(function (fileParam, idParam, typeParam, successCallback, errorCallback) {
                errorCallback(error);
              });
              _context5.next = 9;
              return expect(instance.getFeedItemsWithReplies(feedItems, id, type)).rejects.toMatchObject(error);

            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
  });
  describe('errorCallback()', function () {
    var instance;
    var wrapper;
    var error;
    var code = 'some_code';
    var contextInfo = {
      foo: 'bar'
    };
    beforeEach(function () {
      error = new Error('foo');
      onError = jest.fn();
      wrapper = getWrapper({
        onError: onError
      });
      instance = wrapper.instance();
      jest.spyOn(global.console, 'error').mockImplementation();
    });
    afterEach(function () {
      jest.restoreAllMocks();
    });
    test('should log the error', function () {
      instance.errorCallback(error, code, contextInfo);
      expect(onError).toHaveBeenCalledWith(error, code, contextInfo);
    });
  });
  describe('getApprover()', function () {
    var instance;
    var wrapper;
    test('should get collaborators with groups', function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      var search = 'Santa Claus';
      instance.getApprover(search);
      expect(api.getFileCollaboratorsAPI().getCollaboratorsWithQuery).toBeCalledWith(file.id, instance.getApproverContactsSuccessCallback, instance.errorCallback, search, {
        includeGroups: true
      });
    });
  });
  describe('getApproverContactsSuccessCallback()', function () {
    var instance;
    var wrapper;
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      instance.setState = jest.fn();
    });
    test('should set the feedItems in the state', function () {
      instance.getApproverContactsSuccessCallback(collaborators);
      expect(instance.setState).toBeCalledWith({
        approverSelectorContacts: collaborators.entries
      });
    });
  });
  describe('getMention()', function () {
    var instance;
    var wrapper;
    test('should get collaborators without groups', function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
      var search = 'Santa Claus';
      instance.getMention(search);
      expect(api.getFileCollaboratorsAPI().getCollaboratorsWithQuery).toBeCalledWith(file.id, instance.getMentionContactsSuccessCallback, instance.errorCallback, search);
    });
  });
  describe('getFocusableFeedItemById()', function () {
    test.each(_templateObject8(), [], undefined, undefined, [], '123', undefined, [{
      id: '123',
      type: 'comment'
    }], '123', {
      id: '123',
      type: 'comment'
    }, [{
      id: '123',
      type: 'annotation'
    }], '123', {
      id: '123',
      type: 'annotation'
    }, [{
      id: '123',
      type: 'task'
    }], '123', {
      id: '123',
      type: 'task'
    }, [{
      id: '123',
      type: 'app_activity'
    }], '123', undefined, [{
      id: '123',
      type: 'comment'
    }], '456', undefined)('given feedItems=$feedItems and itemId=$itemId should return $expected', function (_ref13) {
      var feedItems = _ref13.feedItems,
          itemId = _ref13.itemId,
          expected = _ref13.expected;
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      expect(instance.getFocusableFeedItemById(feedItems, itemId)).toEqual(expected);
    });
  });
  describe('getCommentFeedItemByReplyId()', function () {
    test.each(_templateObject9(), [], '123', undefined, [], undefined, undefined, [{
      id: '123',
      type: 'comment',
      replies: [{
        id: '456'
      }]
    }], '123', undefined, [{
      id: '123',
      type: 'comment',
      replies: [{
        id: '456'
      }]
    }], '999', undefined, [{
      id: '123',
      type: 'comment',
      replies: [{
        id: '456'
      }]
    }], '456', {
      id: '123',
      type: 'comment',
      replies: [{
        id: '456'
      }]
    }, [{
      id: '123',
      type: 'comment'
    }], '456', undefined, [{
      id: '123',
      type: 'task',
      replies: [{
        id: '456'
      }]
    }], '456', undefined)('given feedItems=$feedItems and itemId=$itemId should return $expected', function (_ref14) {
      var feedItems = _ref14.feedItems,
          itemId = _ref14.itemId,
          expected = _ref14.expected;
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      expect(instance.getCommentFeedItemByReplyId(feedItems, itemId)).toEqual(expected);
    });
  });
  describe('isActiveEntryInFeed()', function () {
    test.each(_templateObject10(), false, false, false, true, false, true, false, true, true)('should return $expected when getFocusableFeedItemByIdResult returns $getFocusableFeedItemByIdResult and getCommentFeedItemByReplyId returns $getCommentFeedItemByReplyIdResult', function (_ref15) {
      var getFocusableFeedItemByIdResult = _ref15.getFocusableFeedItemByIdResult,
          getCommentFeedItemByReplyIdResult = _ref15.getCommentFeedItemByReplyIdResult,
          expected = _ref15.expected;
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      instance.getFocusableFeedItemById = jest.fn().mockImplementationOnce(function () {
        return getFocusableFeedItemByIdResult;
      });
      instance.getCommentFeedItemByReplyId = jest.fn().mockImplementationOnce(function () {
        return getCommentFeedItemByReplyIdResult;
      });
      expect(instance.isActiveEntryInFeed([], '123')).toEqual(expected);
    });
  });
  describe('isItemTypeFocusable()', function () {
    test.each(_templateObject11(), 'annotation', true, 'app_activity', false, 'comment', true, 'file_version', false, 'task', true)('should return $expected given type=$type', function (_ref16) {
      var type = _ref16.type,
          expected = _ref16.expected;
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      expect(instance.isItemTypeFocusable(type)).toEqual(expected);
    });
  });
  describe('isItemTypeComment()', function () {
    test.each(_templateObject12(), 'annotation', true, 'app_activity', false, 'comment', true, 'file_version', false, 'task', false)('should return $expected given type=$type', function (_ref17) {
      var type = _ref17.type,
          expected = _ref17.expected;
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      expect(instance.isItemTypeComment(type)).toEqual(expected);
    });
  });
  describe('getActiveFeedEntryData()', function () {
    test('should resolve with active feed entry data if active entry is a first level Feed item',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee6() {
      var wrapper, instance, data, result;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              wrapper = getWrapper({
                activeFeedEntryId: '123',
                activeFeedEntryType: 'annotation'
              });
              instance = wrapper.instance();
              data = {
                id: '123',
                type: 'comment'
              };
              instance.getFocusableFeedItemById = jest.fn().mockImplementation(function () {
                return data;
              });
              _context6.next = 6;
              return instance.getActiveFeedEntryData([]);

            case 6:
              result = _context6.sent;
              expect(result).toEqual(data);

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    test('should resolve with active feed entry data if active entry is within replies of any first level Feed items',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee7() {
      var wrapper, instance, data, result;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              wrapper = getWrapper({
                activeFeedEntryId: '123',
                activeFeedEntryType: 'annotation'
              });
              instance = wrapper.instance();
              data = {
                id: '123',
                type: 'comment'
              };
              instance.getFocusableFeedItemById = jest.fn().mockImplementation(function () {
                return undefined;
              });
              instance.getCommentFeedItemByReplyId = jest.fn().mockImplementation(function () {
                return data;
              });
              _context7.next = 7;
              return instance.getActiveFeedEntryData([]);

            case 7:
              result = _context7.sent;
              expect(result).toEqual(data);

            case 9:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    test('should call fetchThreadedComment from feed api if the active entry could not be found within feed items',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee8() {
      var wrapper, instance, expectedData, parentItem, feedItems, result;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              wrapper = getWrapper({
                activeFeedEntryId: '123',
                activeFeedEntryType: 'comment'
              });
              instance = wrapper.instance();
              expectedData = {
                id: '123',
                type: 'comment'
              };
              parentItem = {
                id: '123',
                type: 'comment',
                replies: [{
                  id: '456'
                }]
              };
              feedItems = [parentItem];
              instance.getFocusableFeedItemById = jest.fn().mockImplementation(function () {
                return parentItem;
              }).mockImplementationOnce(function () {
                return undefined;
              });
              instance.getCommentFeedItemByReplyId = jest.fn().mockImplementation(function () {
                return undefined;
              });
              api.getFeedAPI().fetchThreadedComment = jest.fn().mockImplementationOnce(function (f, commentId, successCallback) {
                successCallback({
                  parent: {}
                });
              });
              _context8.next = 10;
              return instance.getActiveFeedEntryData(feedItems);

            case 10:
              result = _context8.sent;
              expect(api.getFeedAPI().fetchThreadedComment).toBeCalledWith(file, '123', expect.any(Function), expect.any(Function));
              expect(result).toMatchObject(expectedData);

            case 13:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    })));
    test('if fetchThreadedComment is called unsuccessfuly and error status is 404, should resolve with {}',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee9() {
      var wrapper, instance, feedItems, error, result;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              wrapper = getWrapper({
                activeFeedEntryId: '123',
                activeFeedEntryType: 'comment'
              });
              instance = wrapper.instance();
              feedItems = [{
                id: '123',
                type: 'comment'
              }];
              error = {
                status: 404
              };
              api.getFeedAPI().fetchThreadedComment = jest.fn().mockImplementationOnce(function (f, commentId, successCallback, errorCallback) {
                errorCallback(error);
              });
              instance.getFocusableFeedItemById = jest.fn().mockImplementation(function () {
                return undefined;
              });
              instance.getCommentFeedItemByReplyId = jest.fn().mockImplementation(function () {
                return undefined;
              });
              _context9.next = 9;
              return instance.getActiveFeedEntryData(feedItems);

            case 9:
              result = _context9.sent;
              expect(result).toMatchObject({});

            case 11:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    })));
    test('if fetchThreadedComment is called unsuccessfuly and error status != 404, should reject with received error',
    /*#__PURE__*/
    _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee10() {
      var wrapper, instance, feedItems, error;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              wrapper = getWrapper({
                activeFeedEntryId: '123',
                activeFeedEntryType: 'comment'
              });
              instance = wrapper.instance();
              feedItems = [{
                id: '123',
                type: 'comment'
              }];
              error = {
                status: 500
              };
              api.getFeedAPI().fetchThreadedComment = jest.fn().mockImplementationOnce(function (f, commentId, successCallback, errorCallback) {
                errorCallback(error);
              });
              instance.getFocusableFeedItemById = jest.fn().mockImplementation(function () {
                return undefined;
              });
              instance.getCommentFeedItemByReplyId = jest.fn().mockImplementation(function () {
                return undefined;
              });
              _context10.next = 9;
              return expect(instance.getActiveFeedEntryData(feedItems)).rejects.toMatchObject(error);

            case 9:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    })));
  });
  describe('getActiveCommentPath()', function () {
    test.each(_templateObject13(), undefined, '/activity', '123', '/activity/comments/123', '456', '/activity/comments/456')('should return $expected given commentId=$commentId', function (_ref23) {
      var commentId = _ref23.commentId,
          expected = _ref23.expected;
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      expect(instance.getActiveCommentPath(commentId)).toEqual(expected);
    });
  });
  describe('getMentionContactsSuccessCallback()', function () {
    var instance;
    var wrapper;
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
    });
    test('should dinamycally set as false contacts loading state', function () {
      instance.setState = jest.fn();
      instance.getMentionContactsSuccessCallback(collaborators);
      expect(instance.setState).toBeCalledWith({
        contactsLoaded: false
      }, expect.any(Function));
    });
    test('should set the feedItems in the state', function () {
      instance.getMentionContactsSuccessCallback(collaborators);
      expect(wrapper.state('contactsLoaded')).toBeTruthy();
      expect(wrapper.state('mentionSelectorContacts')).toEqual(collaborators.entries);
    });
  });
  describe('getReplies()', function () {
    test('should call fetchReplies API', function () {
      var wrapper = getWrapper();
      var instance = wrapper.instance();
      var itemId = '123';
      var itemType = FEED_ITEM_TYPE_COMMENT;
      instance.fetchFeedItems = jest.fn();
      wrapper.instance().getReplies(itemId, itemType);
      expect(api.getFeedAPI().fetchReplies).toBeCalledWith(file, itemId, itemType, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('getAvatarUrl()', function () {
    var wrapper;
    var instance;
    beforeEach(function () {
      wrapper = getWrapper({
        file: file
      });
      instance = wrapper.instance();
    });
    test('should set the current user error and call the error callback', function () {
      var avatarUrl = instance.getAvatarUrl(currentUser.id);
      expect(avatarUrl instanceof Promise).toBe(true);
      expect(usersAPI.getAvatarUrlWithAccessToken).toBeCalledWith(currentUser.id, file.id);
    });
  });
  describe('refresh()', function () {
    var instance;
    var wrapper;
    beforeEach(function () {
      wrapper = getWrapper();
      instance = wrapper.instance();
    });
    test('should fetch the feed items when refresh is called', function () {
      var fetchFeedItems = jest.fn();
      instance.fetchFeedItems = fetchFeedItems;
      instance.refresh();
      expect(fetchFeedItems).toHaveBeenCalled();
      expect(fetchFeedItems).toHaveBeenCalledWith(true);
    });
  });
  describe('handleAnnotationSelect()', function () {
    var annotatorState = {
      activeAnnotationId: '123'
    };
    var emitActiveAnnotationChangeEvent = jest.fn();
    var getAnnotationsMatchPath = jest.fn().mockReturnValue({
      params: {
        fileVersionId: '456'
      }
    });
    var getAnnotationsPath = jest.fn().mockReturnValue('/activity/annotations/235/124');
    var history = {
      push: jest.fn(),
      replace: jest.fn()
    };
    var onAnnotationSelect = jest.fn();

    var getAnnotationWrapper = function getAnnotationWrapper() {
      return getWrapper({
        annotatorState: annotatorState,
        emitActiveAnnotationChangeEvent: emitActiveAnnotationChangeEvent,
        file: file,
        getAnnotationsMatchPath: getAnnotationsMatchPath,
        getAnnotationsPath: getAnnotationsPath,
        history: history,
        onAnnotationSelect: onAnnotationSelect
      });
    };

    test('should call emitAnnotatorActiveChangeEvent and onAnnotatorSelect appropriately', function () {
      var wrapper = getAnnotationWrapper();
      var instance = wrapper.instance();
      var annotation = {
        file_version: {
          id: '235'
        },
        id: '124'
      };
      instance.handleAnnotationSelect(annotation);
      expect(emitActiveAnnotationChangeEvent).toBeCalledWith('124');
      expect(history.push).toHaveBeenCalledWith('/activity/annotations/235/124');
      expect(onAnnotationSelect).toHaveBeenCalledWith(annotation);
    });
    test('should not call history.push if file versions are the same', function () {
      var wrapper = getAnnotationWrapper();
      var instance = wrapper.instance();
      var annotation = {
        file_version: {
          id: '456'
        },
        id: '124'
      };
      instance.handleAnnotationSelect(annotation);
      expect(emitActiveAnnotationChangeEvent).toBeCalledWith('124');
      expect(history.push).not.toHaveBeenCalled();
      expect(onAnnotationSelect).toHaveBeenCalledWith(annotation);
    });
    test('should use current file version if match params returns null', function () {
      var wrapper = getAnnotationWrapper();
      var instance = wrapper.instance();
      var annotation = {
        file_version: {
          id: '235'
        },
        id: '124'
      };
      getAnnotationsMatchPath.mockReturnValue({
        params: {
          fileVersionId: undefined
        }
      });
      instance.handleAnnotationSelect(annotation);
      expect(emitActiveAnnotationChangeEvent).toBeCalledWith('124');
      expect(history.push).toHaveBeenCalledWith('/activity/annotations/235/124');
      expect(onAnnotationSelect).toHaveBeenCalledWith(annotation);
    });
    test('should not call history.push if no file version id on the annotation', function () {
      var wrapper = getAnnotationWrapper();
      var instance = wrapper.instance();
      var annotation = {
        file_version: null,
        id: '124'
      };
      getAnnotationsMatchPath.mockReturnValue({
        params: {
          fileVersionId: undefined
        }
      });
      instance.handleAnnotationSelect(annotation);
      expect(emitActiveAnnotationChangeEvent).toBeCalledWith('124');
      expect(history.push).not.toHaveBeenCalled();
      expect(onAnnotationSelect).toHaveBeenCalledWith(annotation);
    });
  });
  describe('handleAnnotationEdit()', function () {
    test('should call updateAnnotation API and call emitAnnotationUpdateEvent', function () {
      var mockEmitAnnotationUpdateEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationUpdateEvent: mockEmitAnnotationUpdateEvent
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      wrapper.instance().handleAnnotationEdit({
        id: '123',
        permissions: {
          can_edit: true,
          can_delete: true,
          can_resolve: true
        },
        text: 'hello'
      });
      expect(mockEmitAnnotationUpdateEvent).toBeCalledWith({
        id: '123',
        description: {
          message: 'hello'
        }
      }, true);
      expect(api.getFeedAPI().updateAnnotation).toBeCalledWith(expect.anything(), '123', 'hello', undefined, {
        can_edit: true,
        can_delete: true,
        can_resolve: true
      }, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('handleAnnotationStatusChange()', function () {
    test('should call updateAnnotation API and call emitAnnotationUpdateEvent', function () {
      var mockEmitAnnotationUpdateEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationUpdateEvent: mockEmitAnnotationUpdateEvent
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      wrapper.instance().handleAnnotationStatusChange('123', 'open', {
        can_edit: true,
        can_delete: true,
        can_resolve: true
      });
      expect(mockEmitAnnotationUpdateEvent).toBeCalledWith({
        id: '123',
        status: 'open'
      }, true);
      expect(api.getFeedAPI().updateAnnotation).toBeCalledWith(expect.anything(), '123', undefined, 'open', {
        can_edit: true,
        can_delete: true,
        can_resolve: true
      }, expect.any(Function), expect.any(Function));
      expect(instance.fetchFeedItems).toBeCalled();
    });
  });
  describe('handleAnnotationDelete()', function () {
    test('should call deleteAnnotation API and call emitAnnotationDeleteEvent', function () {
      var mockEmitAnnotationRemoveEvent = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationRemoveEvent: mockEmitAnnotationRemoveEvent
      });
      var instance = wrapper.instance();
      instance.fetchFeedItems = jest.fn();
      wrapper.instance().handleAnnotationDelete({
        id: '123'
      });
      expect(mockEmitAnnotationRemoveEvent).toBeCalledWith('123', true);
      expect(api.getFeedAPI().deleteAnnotation).toBeCalled();
      expect(instance.fetchFeedItems).toHaveBeenCalled();
    });
  });
  describe('deleteAnnotationSuccess()', function () {
    test('should handle successful annotation deletion', function () {
      var mockEmitAnnotationRemoveEvent = jest.fn();
      var mockFeedSuccess = jest.fn();
      var wrapper = getWrapper({
        emitAnnotationRemoveEvent: mockEmitAnnotationRemoveEvent
      });
      var instance = wrapper.instance();
      instance.feedSuccessCallback = mockFeedSuccess;
      instance.deleteAnnotationSuccess('123');
      expect(mockEmitAnnotationRemoveEvent).toBeCalledWith('123');
      expect(mockFeedSuccess).toBeCalled();
    });
  });
  describe('getFilteredFeedItems()', function () {
    var expectedAnnotationOpen = filterableActivityFeedItems.annotationOpen,
        expectedAnnotationResolved = filterableActivityFeedItems.annotationResolved,
        expectedCommentOpen = filterableActivityFeedItems.commentOpen,
        expectedCommentResolved = filterableActivityFeedItems.commentResolved,
        expectedTaskItem = filterableActivityFeedItems.taskItem,
        expectedVersionItem = filterableActivityFeedItems.versionItem;
    test.each(_templateObject14(), undefined, [expectedAnnotationOpen, expectedAnnotationResolved, expectedCommentOpen, expectedCommentResolved, expectedTaskItem, expectedVersionItem], 'open', [expectedAnnotationOpen, expectedCommentOpen, expectedVersionItem], 'resolved', [expectedAnnotationResolved, expectedCommentResolved, expectedVersionItem], 'task', [expectedTaskItem, expectedVersionItem])('should filter feed items of type "comment" or "annotation" based on status equal to $status', function (_ref24) {
      var status = _ref24.status,
          expected = _ref24.expected;

      var _cloneDeep = cloneDeep(filterableActivityFeedItems),
          annotationOpen = _cloneDeep.annotationOpen,
          annotationResolved = _cloneDeep.annotationResolved,
          commentOpen = _cloneDeep.commentOpen,
          commentResolved = _cloneDeep.commentResolved,
          taskItem = _cloneDeep.taskItem,
          versionItem = _cloneDeep.versionItem;

      var wrapper = getWrapper();
      var instance = wrapper.instance();
      instance.setState({
        feedItems: [annotationOpen, annotationResolved, commentOpen, commentResolved, taskItem, versionItem]
      });
      instance.setState({
        feedItemsStatusFilter: status
      });
      expect(instance.getFilteredFeedItems()).toMatchObject(expected);
    });
  });
  describe('handleItemsFiltered()', function () {
    test.each(_templateObject15(), undefined, undefined, 'open', 'open', 'resolved', 'resolved', 'task', 'task')('given $status should update feedItemsStatusFilter state with $expected and call filter change event callback', function (_ref25) {
      var status = _ref25.status,
          expected = _ref25.expected;
      var mockOnFilterChange = jest.fn();
      var wrapper = getWrapper({
        onFilterChange: mockOnFilterChange
      });
      var instance = wrapper.instance();
      instance.setState = jest.fn();
      instance.handleItemsFiltered(status);
      expect(instance.setState).toBeCalledWith({
        feedItemsStatusFilter: expected
      });
      expect(mockOnFilterChange).toBeCalledWith(expected);
    });
  });
  describe('renderAddTaskButton()', function () {
    test('should return null when hasTasks is false', function () {
      var wrapper = getWrapper({
        hasTasks: false
      });
      var instance = wrapper.instance();
      expect(instance.renderAddTaskButton()).toBe(null);
    });
  });
  describe('renderActivitySidebarFilter()', function () {
    describe('should return null', function () {
      test('when activityFeed.filter feature is not set', function () {
        var wrapper = getWrapper();
        var instance = wrapper.instance();
        expect(instance.renderActivitySidebarFilter()).toBe(null);
      });
      test('when activityFeed.filter feature is disabled', function () {
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: false
              }
            }
          }
        });
        var instance = wrapper.instance();
        expect(instance.renderActivitySidebarFilter()).toBe(null);
      });
      test.each(_templateObject16(), false, true)('when activityFeed.newThreadedReplies is not enabled and hasTasks is $hasTasks', function (_ref26) {
        var hasTasks = _ref26.hasTasks;
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              newThreadedReplies: {
                enabled: false
              }
            }
          },
          hasTasks: hasTasks
        });
        var instance = wrapper.instance();
        expect(instance.renderActivitySidebarFilter()).toBe(null);
      });
    });
    describe('should return ActivitySidebarFilter', function () {
      test('when activityFeed.filter feature is enabled', function () {
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: true
              }
            }
          }
        });
        var instance = wrapper.instance();
        var resultWrapper = mount(instance.renderActivitySidebarFilter());
        expect(resultWrapper.name()).toBe('ActivitySidebarFilter');
      });
      test('with default filter options when activityFeed.filter is enabled', function () {
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: true
              }
            }
          },
          hasTasks: true
        });
        var instance = wrapper.instance();
        var resultWrapper = mount(instance.renderActivitySidebarFilter());
        var sidebarFilter = resultWrapper.find(ActivitySidebarFilter).first();
        expect(resultWrapper.name()).toBe('ActivitySidebarFilter');
        expect(sidebarFilter.props().activityFilterOptions).toEqual(['all', 'open']);
      });
      test.each(_templateObject17(), ['all', 'open', 'resolved'], false, ['all', 'open', 'resolved', 'tasks'], true)('with $expectedOptions filter options when activityFeed.newThreadedReplies is enabled, activityFeed.filter is enabled, and hasTasks is $hasTasks', function (_ref27) {
        var expectedOptions = _ref27.expectedOptions,
            hasTasks = _ref27.hasTasks;
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: true
              },
              newThreadedReplies: {
                enabled: true
              }
            }
          },
          hasTasks: hasTasks
        });
        var instance = wrapper.instance();
        var resultWrapper = mount(instance.renderActivitySidebarFilter());
        var sidebarFilter = resultWrapper.find(ActivitySidebarFilter).first();
        expect(resultWrapper.name()).toBe('ActivitySidebarFilter');
        expect(sidebarFilter.props().activityFilterOptions).toEqual(expectedOptions);
      });
    });
  });
  describe('renderTitle()', function () {
    describe('should return FormattedMessage', function () {
      test('when activityFeed.filter feature is not set', function () {
        var wrapper = getWrapper();
        var instance = wrapper.instance();
        var resultWrapper = mount(instance.renderTitle());
        expect(resultWrapper.name()).toBe('FormattedMessage');
      });
      test('when activityFeed.filter feature is disabled', function () {
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: false
              }
            }
          }
        });
        var instance = wrapper.instance();
        var resultWrapper = mount(instance.renderTitle());
        expect(resultWrapper.name()).toBe('FormattedMessage');
      });
      test.each(_templateObject18(), false, true)('when activityFeed.newThreadedReplies is disabled and hasTasks is $hasTasks', function (_ref28) {
        var hasTasks = _ref28.hasTasks;
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              newThreadedReplies: {
                enabled: false
              }
            }
          },
          hasTasks: hasTasks
        });
        var instance = wrapper.instance();
        var resultWrapper = mount(instance.renderTitle());
        expect(resultWrapper.name()).toBe('FormattedMessage');
      });
    });
    describe('should return null', function () {
      test('when activityFeed.filter feature is enabled', function () {
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: true
              }
            }
          }
        });
        var instance = wrapper.instance();
        expect(instance.renderTitle()).toBe(null);
      });
      test.each(_templateObject19(), false, true)('when activityFeed.newThreadedReplies is enabled, activityFeed.filter is enabled, and hasTasks is $hasTasks', function (_ref29) {
        var hasTasks = _ref29.hasTasks;
        var wrapper = getWrapper({
          features: {
            activityFeed: {
              filter: {
                enabled: true
              },
              newThreadedReplies: {
                enabled: true
              }
            }
          },
          hasTasks: hasTasks
        });
        var instance = wrapper.instance();
        expect(instance.renderTitle()).toBe(null);
      });
    });
  });
});